//https://school.programmers.co.kr/learn/courses/30/lessons/92344
//파괴되지 않은 건물

// 파괴되지 않은 건물
function solution(board, skill) {
  var answer = 0;

  // 누적합을 위한 배열 생성 (크기는 board보다 1씩 더 크게)
  const arr = Array.from({ length: board.length + 1 }, () =>
    Array(board[0].length + 1).fill(0)
  );

  // 스킬 타입에 따른 값 계산 (1: 공격(-), 2: 회복(+))
  const type = (t, d) => {
    return t === 1 ? -d : d;
  };

  skill.forEach((element) => {
    // 직사각형 영역 마킹 함수
    function makrEdge(effect, r1, c1, r2, c2, degree) {
      const value = type(element[0], degree);
      effect[r1][c1] += value; // 왼쪽 위 모서리
      effect[r1][c2 + 1] -= value; // 오른쪽 위 모서리 바깥
      effect[r2 + 1][c1] -= value; // 왼쪽 아래 모서리 바깥
      effect[r2 + 1][c2 + 1] += value; // 오른쪽 아래 모서리 바깥
    }

    // 각 스킬마다 영역 마킹
    makrEdge(
      arr,
      element[1], // r1 (시작 행)
      element[2], // c1 (시작 열)
      element[3], // r2 (끝 행)
      element[4], // c2 (끝 열)
      element[5] // 수치
    );
  });

  // 행 방향 누적합 계산
  for (let i = 0; i < arr.length; i++) {
    for (let j = 1; j < arr[0].length; j++) {
      arr[i][j] += arr[i][j - 1];
    }
  }

  // 열 방향 누적합 계산
  for (let j = 0; j < arr[0].length; j++) {
    for (let i = 1; i < arr.length; i++) {
      arr[i][j] += arr[i - 1][j];
    }
  }

  // 최종 board 상태 계산 및 파괴되지 않은 건물 카운트
  for (let i = 0; i < board.length; i++) {
    for (let j = 0; j < board[0].length; j++) {
      board[i][j] += arr[i][j];
      if (board[i][j] > 0) answer++;
    }
  }

  return answer;
}

const board = [
  [5, 5, 5, 5, 5],
  [5, 5, 5, 5, 5],
  [5, 5, 5, 5, 5],
  [5, 5, 5, 5, 5],
];
const skill = [
  [1, 0, 0, 3, 4, 4],
  [1, 2, 0, 2, 3, 2],
  [2, 1, 0, 3, 1, 2],
  [1, 0, 1, 3, 3, 1],
]; //[공격/회복,x1,y1,x2,y2,내구도(증감량)] x 행, y 열
console.log(solution(board, skill));

/**
 * 
 * 배열 초기화: 누적합을 위한 배열을 board보다 가로/세로로 1씩 더 크게 만듭니다.
 * 
 * 스킬 적용: 각 스킬마다 직사각형 영역의 4개 모서리 지점만 표시합니다.
 * 
 * 왼쪽 위: 값 추가
 * 오른쪽 위 바깥: 값 제거
 * 왼쪽 아래 바깥: 값 제거
 * 오른쪽 아래 바깥: 값 추가
 * 
 * 누적합 계산:
 * 행 방향으로 먼저 누적합 계산
 * 열 방향으로 누적합 계산
 * 
 * 결과 계산: 원래 board에 누적합 배열의 값을 더하고 양수인 값(파괴되지 않은 건물)의 개수를 세어 반환
 * 
이 방식은 시간 복잡도를 O(K×N×M)에서 O(K + N×M)으로 크게 줄여주는 매우 효율적인 알고리즘입니다.
 */

/**
 * 아래와 같이 (1,1)에서 (3,3) 크기에 10을 더한다 할 때
 * 0 0 0 0 0      0  0  0  0  0
 * 0 0 0 0 0      0 10 10 10  0
 * 0 0 0 0 0  →  0 10 10 10  0
 * 0 0 0 0 0      0 10 10 10  0
 * 0 0 0 0 0      0  0  0  0  0
 *
 * 누적합 방법
 * 마킹: 직사각형 영역의 네 꼭지점만 표시
 *
 * (y1, x1): 값(degree)
 * (y1, x2+1): -값
 * (y2+1, x1): -값
 * (y2+1, x2+1): 값
 *
 * 1. 먼저 경계만 표시
 * 0   0   0   0   0
 * 0  +10  0   0  -10
 * 0   0   0   0   0
 * 0   0   0   0   0
 * 0  -10  0   0  +10
 *
 * 2. 행 방향 누적합 계산
 *
 * 0   0   0   0   0
 * 0  +10 +10 +10  0
 * 0   0   0   0   0
 * 0   0   0   0   0
 * 0  -10 -10 -10  0
 *
 * 3. 열 방향 누적합 계산
 * 0   0   0   0   0
 * 0  +10 +10 +10  0
 * 0  +10 +10 +10  0
 * 0  +10 +10 +10  0
 * 0   0   0   0   0
 *
 *핵심 원리
 * 네 모서리만 표시하고, 누적합 계산을 통해 전체 영역에 효과가 확산됩니다
 * 시작점(왼쪽 위)에 +값, 그리고 경계 밖에 -값을 놓아서 값이 "채워지고" "차단되는" 효과를 만듭니다
 * 두 번의 누적합 계산(행 방향, 열 방향)으로 전체 직사각형 영역이 정확히 업데이트됩니다
 * 이 방법은 여러 직사각형 영역 업데이트가 있을 때 특히 효율적입니다. 시간복잡도가 O(영역 크기)에서 O(1)로 줄어들기 때문입니다
 *
 */
