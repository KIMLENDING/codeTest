//https://school.programmers.co.kr/learn/courses/30/lessons/152995

/**
 *[6,3],[5,1],[2,3](원호) 이런 식이면
 * [5,1]인 사람은 점수는 높지만 인센티브를 받지 못하는데 [6,3]때문에
 * 근데 원호는 총점이 5점이지만 [6,3]과 비교해도 동료평가는 이겨 [5,1]과 비교해도 동료 평가는 이겨
 * 그럼 원호는 합산 점수 등수는 3등이지만 [5,1]인센티브를 못받으니까 원호의 등수가 당겨지는데 ?
 * 이걸 찾아야 하네 ..... 이건 maxB를 사용해서 해결을 했지만
 * 문제는 정렬에 있었네
 *
 * *정렬방식 *
 *  점수 합을 기준으로 정렬
 * [[10, 10], [15, 5], [5, 20]]
 * (10, 10) → (15, 5) → (5, 20) // 근무 태도 점수가 낮은 사람이 먼저 나올 수도 있음
 * 근무 태도 점수 기준 정렬
 *(15, 5) → (10, 10) → (5, 20) // 앞에서부터 순차적으로 탈락 체크 가능
 * *정렬 방식을 점수 합이 아닌 근무 태도를 기준으로 하는 이유는
 * 아래 조건문 때문
 *
 * 점수 합이 높은 순으로 정렬을 하니 근무태도가 낮아도 합이 높으면 앞에 배치되는 문제가 있음
 * 이렇게 되면 아래 탈락 조건 판단 문에서
 * 순차적으로 나오는 [근무태도,동료평가]에서
 * 근무태도가 (앞쪽 근무태도 > 뒤 쪽 근무 태도) 보다 확정적으로 크다라고 할 수 없음
 * 그렇게 되면  if (b < maxB) continue;(현재 사람은 인센티브를 못 받으므로 건너뛴다.)
 * 이 조건을 만족할 수 없게 된다. 저 조건의 전제는 근무태도는 내림차순으로 정렬 되어 있어야만 가능하기 때문
 * 이유는 a도 비교하고 b를 비교하는게 아니라 *****b만 비교하기 때문임****
 *
 */
function solution(scores) {
  const wanho = scores[0]; // 완호의 점수

  // 1. 근무 태도를 기준으로 내림차순
  scores.sort((a, b) => {
    if (a[0] === b[0]) return a[1] - b[1]; // 근무 태도 점수가 같다면 동료 평가 점수 오름차순
    return b[0] - a[0]; // 근무 태도 점수 기준 내림차순
  });
  console.log(scores);
  let rank = 1;
  let maxB = 0; // 원호의 앞에 있는 사람중 인센티브를 못받는 사람을 제외하고 원호의 순위를 매기기 위한 변수
  for (const [a, b] of scores) {
    if (a > wanho[0] && b > wanho[1]) return -1; // 완호 탈락
    //  maxB보다 작은 b 값을 가지는 경우 탈락
    if (b < maxB) continue; // 현재 사람은 인센티브를 못 받으므로 건너뛴다.
    maxB = b; // maxB 갱신
    //현재 점수 합이 완호보다 크면 순위 증가
    if (a + b > wanho[0] + wanho[1]) rank++;
  }

  return rank;
}
const scores = [
  [2, 2],
  [1, 4],
  [3, 2],
  [3, 2],
  [2, 1],
];
console.log(solution(scores));
